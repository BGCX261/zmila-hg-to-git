
function problem( )
{
	
}

////////////////////////////////////////////////////////////////////////////////

/*
What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?"
*/
function problem46()
{
	return 5777;
}


/*
Find the smallest cube for which exactly five permutations of its digits are cube.
*/
function problem62()
{
	return 127035954683;	// 5027^3
	// ([5027 127035954683] [7061 352045367981] [7202 373559126408] [8288 569310543872] [8384 589323567104])
}


/* Find the sum of all 0 to 9 pandigital numbers with this property. */
function problem043()
{
	return 16695334890;	// (4106357289 4130952867 4160357289 1406357289 1430952867 1460357289)
}



/*
Find the number of integers 1 < n < 10^(7), for which n and n + 1 have the same number of positive divisors. 
For example, 14 has the positive divisors 1, 2, 7, 14 while 15 has 1, 3, 5, 15.
*/
function problem179()
{
	return 986262;	// 31907/200 (exactly 159.535) s (time)
}

/*
How many reversible numbers are there below one-billion (10^(9))?
*/
function problem145()
{
	return 608720
}

/*
Find the value of n ≤ 1,000,000 for which n/φ(n) is a maximum.
*/
function problem69()
{
  return 510510;  //510510/92160 = 17017/3072 (approx. 5.539388020833333)
}

/*
Find the value of n, 1 < n < 10^(7), for which φ(n) is a permutation of n and the ratio n/φ(n) produces a minimum.
*/
function problem70()
{
  return 8319823; // 8319823/8313928 (approx. 1.0007090511248113)
}

/*Problem 206
Concealed Square
Find the unique positive integer whose square has the form 1_2_3_4_5_6_7_8_9_0,
where each “_” is a single digit.
*/
function problem206()
{
	return 1389019170; //1929374254627488900
}

/*
How many elements would be contained in the set of reduced proper fractions for d ≤ 1,000,000?
*/
function problem72( )
{
	return 303963552391;
}


/*
Given that F_(k) is the first Fibonacci number for which 
the first nine digits AND the last nine digits are 1-9 pandigital, find k.
*/
function problem104( )
{
	// F(329468) = 245681739...352786941
	return 329468;
}


/*
Considering natural numbers of the form, a^(b), where a, b < 100, what is the maximum digital sum?
*/
function problem56( )
{
	return 972;
}

/*
How many distinct terms are in the sequence generated by a^(b) for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?"
*/
function problem29( )
{
	return 9183;
}

/*
TODO oeu
The palindromic number 595 is interesting because it can be written as the sum of consecutive squares: 6^(2) + 7^(2) + 8^(2) + 9^(2) + 10^(2) + 11^(2) + 12^(2).

There are exactly eleven palindromes below one-thousand that can be written as consecutive square sums, and the sum of these palindromes is 4164. Note that 1 = 0^(2) + 1^(2) has not been included as this problem is concerned with the squares of positive integers.

Find the sum of all the numbers less than 10^(8) that are both palindromic and can be written as the sum of consecutive squares.
*/
function problem125( limit )
{
  limit = limit || 100000000;
  var sqLimit = Math.floor( Math.sqrt(limit) );

  function isPalindrom(n)
  {
    var n1 = n
    var digits = []
    while ( n >= 10 )
    {
      var rem = n % 10;
      digits.push( rem ); // order is reversed, but who cares in palindrom case
      n = Math.floor(n / 10);
    }
    digits.push( n );
    //console.log( n1, digits );

    for ( var left = 0, right = digits.length-1; left<right; left++, right-- )
    {
      if ( digits[left] != digits[right] )
        return false;
    }

    return true;
  }

  var squares = [];
  for ( var i = 0; i < sqLimit; i++ )
    squares[i] = i*i;

  var allPalindroms = {}; // object as set
  var first = 1;
  while ( first < sqLimit )
  {
    var palindrom = squares[first];
    var last = first+1;
    while ( last < sqLimit )
    {
      palindrom += squares[last];
      if ( palindrom > limit )
        break;

      if ( isPalindrom(palindrom) )
      {
        allPalindroms[palindrom] = true;
      }
      last++;
    }
    
    first++;
  }

  var res = 0;
  for ( var key in allPalindroms )
    res += key;
  
  return res; // 2906969179
}


function problem27()
{

var res = Sieve_of_Eratosthenes();

var primes = res[0]
var arrPrimes = res[1];

var indPrimeGT1000 = -1; 
for ( var i = 0; i < arrPrimes.length; i++ )
  if ( arrPrimes[i] > 1000 )
    { indPrimeGT1000 = i; break; }

function isPrime( n ) { return !!primes[n] }

var maxLen = 0, maxA, maxB, n;

// uses maxLen = 0, maxA, maxB
function getLen(A, B)
{
  var n = 0;
  while ( true )
  {
    var prime = n*n + A*n + B;
    n++;
    if ( prime <= 0 || !isPrime(prime) )
      break;
  }

  if ( n > maxLen )
  {
    maxA = A; 
    maxB = B; 
    maxLen = n; 
    //log( "current: " + maxA + " " + maxB + " " + maxLen ); 
    return true;
  }

  return false;
}

for ( var a = 0; a < indPrimeGT1000; a++ )
{
  var A = arrPrimes[a];
  for ( var b = 0; b < indPrimeGT1000; b++ )
  {
    var B = arrPrimes[b];
    //getLen(A, B)
    getLen(-A, B)
    getLen(A, -B)
    //getLen(-A, -B)
  }
}

log( "final: " + maxA + " " + maxB + " " + maxLen )

  return [ maxA, maxB, maxA*maxB ];
}


/*
Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.
  allAbundant = 6965
  sumOfAllNotSumOfTwoAbundant = 4179871
  their count = 1456
*/
function problem102() 
{
  return 4179871;
}

/*
For how many triangles in the text file does the interior contain the origin?
*/
function problem102() 
{

function sameSide( x1,y1, x2,y2, x3,y3 )  
{
  function angle(dx,dy) 
  {
    var angle;
    if (dx == 0)
    {
      angle = dy < 0 ? -Math.PI/2 : Math.PI/2
    }
    else
    {
      angle = Math.atan(dy/dx)
      if (dx < 0)
        angle = Math.PI + angle
    }
    return angle / Math.PI * 180
  }

  function angle2(x1,y1, x2,y2) 
  {
    var dx = x2-x1
    var dy = y2-y1
    return angle(dx,dy)
  }

	var angle10 = angle2(x1,y1, 0,0)
	var angle12 = angle2(x1,y1, x2,y2)
	var angle13 = angle2(x1,y1, x3,y3)

  function angle1LTangle2( angle1, angle2 )
  {
    if ( Math.abs( angle1 - angle2 ) > 180 )
    {
      if ( angle1 > angle2 )
        angle1 = angle1 - 360
      else
        angle2 = angle2 - 360
    }
    return angle1 < angle2
  }
  
	if ( angle1LTangle2(angle10, angle12) )
		return angle1LTangle2(angle10, angle13);
	if ( angle1LTangle2(angle12, angle10) )
		return angle1LTangle2(angle13, angle10);

  return false
}

function originInsideTriangle( x1,y1, x2,y2, x3,y3 )  
{
	if (x1 > 0 && x2 > 0 && x3 > 0)
		return false
	if (y1 > 0 && y2 > 0 && y3 > 0)
		return false

	if (sameSide( x1,y1, x2,y2, x3,y3 ))
    return false
	if (sameSide( x2,y2, x1,y1, x3,y3 ))
    return false
	
	return true
}

var triangles = 
[
  [-340,495,-153,-910,835,-947],  // true
  [-175,41,-421,-714,574,-645]  // false
  //, ... 998 more
];

var inside = 0;
for ( var i = 0; i < triangles.length; i++ )
{
  var t = triangles[i];
  if ( originInsideTriangle( t[0],t[1],  t[2],t[3], t[4],t[5] ) )
    inside++;
}

console.log( "inside = ", inside );
return inside;  //228
}


/*
  Find the first four consecutive integers to have four distinct primes factors. 
  What is the first of these numbers?
*/
function problem47()
{
	return 134043
}


/*
  solve 50 sudoku
*/
function problem96()
{
  return 24702;
}


function problem80()
{
	// initial data: array of strings with square roots, all[i] = sqrt(i) without decimal point
	{
		var all = [	"",
			"1414213562373095048801688724209698078569671875376948073176679737990732478462107038850387534327641572735",
      //...
			"9899494936611665341611821069467886549987703127638636512236758165935127349234749271952712740293491009145",
			"9949874371066199547344798210012060051781265636768060791176046438349453927827131540126530197384871952721"
		]		
	}

	var sum = 0;
	for ( var i = 0; i < all.length; i++ )
	{
			var root = all[i];
			if ( root.length == 0 ) continue;
			for ( var c = 0; c < 100; c++ )
					sum += +root.charAt(c);
	}
	return sum; //40886
}

/*
How many chains, with a starting number below one million, contain exactly sixty non-repeating terms?

permutations of 1479 and 0479
and then 223479
*/
function problem74(N)
{
  var factorials = (function () {
    var res = []
    res[0] = 1
    for ( var i = 1; i < 10; i++ )
    {
      res[i] = i * res[i-1]
    }
    return res;
  }) ()

  function getNext( curr )
  {
    var next = 0
    while( curr > 0 )
    {
      var d = factorials[curr % 10]
      next += d
      curr = Math.floor( curr / 10 )
    }
    return next
  }

  function getChainLen( path )
  {
    var last = path[path.length-1]
    var next = getNext(last)
    var ind = path.indexOf(next)
    if ( ind == -1 )
    {
      path.push(next)
      if ( path.length > 60 )
        return 61;
      else
        return getChainLen( path )
    }
    else
    {
      return path.length
    }
  }

  
  var found = []
  for ( var i = 3; i < 100; i++ )
  {
    var path = getChain( [i] )
    console.log( i, path.length )
    allPaths[i] = path.length
    if ( path.length == 60 )
    {
      found.push( i );
      console.log( "60: ", i )
    }
    if ( i % 10000 == 0 )
      console.log( " trace i=", i );
  }

  return found.length;  // 402
}


/*
x0 = y0 = 0
Given that 0 <= x_(1), y_(1), x_(2), y_(2) <= 50, how many right triangles can be formed?
*/
function problem91(N)
{
  return 14234;
}

/* Investigating the number of rectangles in a rectangular grid. */
function problem85()
{
  return 2772;
  // size=36x77, area=2772, count=1999998, min diff=2
}

/*
25	12	p7
56	25	p4
82	56	p3
28	82	p5
81	28	p6
12	81	p8

sum=28684
*/
function problem61( )
{
	return 28684;
}

/*
1487	4817	8147
2969	6299	9629
*/
function problem49( input )
{
	return 296962999629;
}

// the largest 7-digit pandigital prime 7652413
function problem41()
{
	return 7652413;
}

// sum of products: 45228
function problem32()
{
	return 45228;
}

function problem50()
{
var primes = Sieve_of_Eratosthenes();
var limit = 1000000;
var maxLen = 21;
for ( var start = 0; start < primes.length-1  && primes[start+maxLen] < limit; start++ )
{
    var sum = 0;
    for ( var end = start+1; end < primes.length; end++ )
    {
        if ( sum + primes[end] < limit )
            sum += primes[end];
        else
            break;
    }

    if ( end-start-1 > maxLen )
        if ( primes.indexOf(sum) >= 0 )
        {
            maxLen = end-start-1; maxPrime = sum;
            console.log( start, end, maxLen, maxPrime );
        }
}
console.log( "finally", maxLen, maxPrime );
//543 997651
return maxPrime;
}

function problem87()
{
var limit = 50000000;
var l2 = Math.sqrt( limit );

var res = {};
var primes = Sieve_of_Eratosthenes();
/*
var primes = [2];
	for ( var p = 0; p < halfLimit; p++)
	{
		 if ( era[p] )
		{
			primes.push(2*p + 1);
		}
	}
*/

var count = 0;
var p2s = [], p3s = [], p4s = [];
for ( var a = 0; a < l2; a++ )
{
  var pa = primes[a];
  var p2 = pa*pa;
  if ( p2 > limit ) break;
  p2s[a] = p2;

  var p3 = p2*pa;
  if ( p3 > limit ) continue;
  p3s[a] = p3;

  var p4 = p3*pa;
  if ( p4 > limit ) continue;
  p4s[a] = p4;
}

console.log( primes.length, p2s.length, p3s.length, p4s.length );
console.log( p2s[p2s.length-1], p3s[p3s.length-1], p4s[p4s.length-1] );

var all = {};
for ( var i4 = 0; i4 < p4s.length; i4++ )
{
  var sum4 = p4s[i4];
  if ( sum4 > limit ) break;

  for ( var i3 = 0; i3 < p3s.length; i3++ )
  {
    var sum3 = sum4 + p3s[i3];
    if ( sum3 > limit ) break;

    for ( var i2 = 0; i2 < p2s.length; i2++ )
    {
      var sum2 = sum3 + p2s[i2];
      if ( sum2 > limit ) break;

      //all.push([sum2, i2, i3, i4]);
      all[sum2] = [i2, i3, i4];
    }
  }
}
//alert( answer );
//return answer; //all.length;
//11251788

var count = 0;
for ( var r in all )
{
  count++;
}

console.log( count );
return count;
}


/*
the minimal path sum from the top left to the bottom right, by moving left, right, up, and down
Dijkstra algorithm
*/
function problem83()
{
function neigbours( r, c )
{
  var ns = [];
  if ( c > 0 )
    ns.push([r, c-1]);
  if ( c < len-1 )
    ns.push([r, c+1]);

  if ( r > 0 )
    ns.push([r-1, c]);
  if ( r < len-1 )
    ns.push([r+1, c]);

  return ns;
}

var data =
[[131, 673, 234, 103, 18],
[201, 96, 342, 965, 150],
[630, 803, 746, 422, 111],
[537, 699, 497, 121, 956],
[805, 732, 524, 37, 331]];  //2297

var len = data.length;

var mins = [];
for ( var r = 0; r < len; r++ )
{
    var row = mins[r] = [];
    for ( var c = 0; c < len; c++ )
        row[c] = Infinity;
}

var que = {};
mins[0][0] = data[0][0];
que["0:0"] = [0,0];

var changed;
do
{
  changed = false;
  console.dir( que );
  for ( var k in que )
  {
    var koord = que[k];
    delete que[k];

    var pathCost = mins[koord[0]][koord[1]];
    var ns = neigbours( koord[0], koord[1] );
    ns.forEach( function(nei)
    {
      var newCost = data[nei[0]][nei[1]] + pathCost;
      var currMin = mins[nei[0]][nei[1]];
      if ( currMin > newCost )
      {
        mins[nei[0]][nei[1]] = newCost;
        que[nei[0]+":"+nei[1]] = nei;
        changed = true;
      }
    } );
  }
}
while ( changed );

return mins[len-1][len-1];  // 425185
}

/*
Problem 77
It is possible to write ten as the sum of primes in exactly five different ways:
7 + 3
5 + 5
5 + 3 + 2
3 + 3 + 2 + 2
2 + 2 + 2 + 2 + 2
What is the first value which can be written as the sum of primes in over five thousand different ways?
*/
function problem77()
{

  var primes = Sieve_of_Eratosthenes();

  function findFloorPrime( n )
  {
      if ( n < 2 ) return NaN;
      while ( !primes[n] )
          n--;
      return n;
  }

  var memo = {};
  function divide( what, max, way )
  {
    if ( what == 0 )
    {
      console.log( way );
      return 1;
    }
    var key = what+":"+max, val = memo[key];
    if ( val )
    {
      console.log( way, key, val );
      return val;
    }
    var curr = findFloorPrime(Math.min(what, max));
    if ( !curr )
      return 0;
    var ways = 0;
    while ( curr )
    {
      var newWay = [].concat( way );
      newWay.push( curr );
      ways += divide( what-curr, curr, newWay );
      curr = findFloorPrime(curr-1);
    }
    memo[ key ] = ways;
    return ways;
  }


  var howMuch = 0;
  for ( var i = 10; i < 80; i++ )
  {
    howMuch = divide(i, i, []);
    if ( howMuch > 5000 )
    {
      console.log( "howMuch", i, howMuch );
      break;
    }
  }

  return i; // 71 -- 5007
}

/*
I = 1
V = 5
X = 10
L = 50
C = 100
D = 500
M = 1000
# Only I, X, and C can be used as the leading numeral in part of a subtractive pair.
# I can only be placed before V and X.
# X can only be placed before L and C.
# C can only be placed before D and M

Numerals must be arranged in descending order of size.

The text file, roman.txt, contains one thousand numbers written in valid, but not necessarily minimal, Roman numerals.

Find the number of characters saved by writing each of these in their minimal form.
*/
function problem89(input)
{
  var roman = { "I":1, "V":5, "X":10, "L":50, "C":100, "D":500, "M":1000 };

function fromRoman( item )
{
  var val = 0;
  item.forEach( function(ch) { sum+=roman[ch]; } );
  return val;
}

function toRoman( item )
{
  var res = "";

  while ( item > 1000 )
  {
    res += "M";
    item -= 1000;
  }

  if ( item > 100 )
  {
    var d = item / 100;
    res += convertDigit( d, "C", "D", "M" );
    item = item % 100;
  }

  if ( item > 10 )
  {
    var d = item / 10;
    res += convertDigit( d, "X", "L", "C" );
    item = item % 10;
  }

  if ( item > 1 )
  {
    var d = item;
    res += convertDigit( d, "I", "V", "X" );
  }

  return res;

  function convertDigit( d, one, five, ten )
  {
    switch (d)
    {
      case 9: return one + ten;
      case 8: return five + one + one + one;
      case 7: return five + one + one;
      case 6: return five + one;
      case 5: return five;
      case 4: return one + five;
      case 3: return one + one + one;
      case 2: return one + one;
      case 1: return one;
    }
  }
}


  var save = 0;
  var repl = [["DCCCC","CM"], ["CCCC","CD"], ["LXXXX","XC"],
    ["XXXX","XL"], ["VIIII","IX"], ["IIII","IV"]];
  data.forEach( function(item)
  {
      var original = item.length;
      repl.forEach( function( r ) { item = item.replace( r[0], r[1] ); } );
      save += original - item.length;
  } );
  console.log( save );

  return save;
}


function problem76(input)
{
var memo = {};
function divide( what, max )
{
  if ( what == 0 )
    return 1;
  var key = what+":"+max, val = memo[key];
  if ( val )
    return val;
  var ways = 0;
  for ( var i = Math.min(what, max); i > 0; i-- )
    ways += divide( what-i, i );
  memo[ key ] = ways;
  return ways;
}

divide(100, 99);

var n = +input;
return divide( n, n-1 );
}

function problem78()
{
var p = [];
p[0] = 1;

var sign, f;

for ( var n = 1; n < 100; n++ )
{
  sign = 1;
  p[n] = 0;
  for ( var k = 1; k < 100; k++ )
  {
    f = k*(3*k - 1) / 2;
    if ( f > n ) break; // p[n-f] == 0
    p[n] += sign*p[n-f];
    f = k*(3*k + 1) / 2;
    if ( f > n ) break; // p[n-f] == 0
    p[n] += sign*p[n-f];
    sign = -sign;
  }
}

return p[100]-1;
}


/*
Pentagonal numbers are generated by the formula, P_(n)=n(3n?1)/2. The first ten pentagonal numbers are:
1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
It can be seen that P_(4) + P_(7) = 22 + 70 = 92 = P_(8). However, their difference, 70 ? 22 = 48, is not pentagonal.
Find the pair of pentagonal numbers, P_(j) and P_(k), for which their sum and difference is pentagonal and D = |P_(k) ? P_(j)| is minimised; what is the value of D?
// pa < pb < pc < pd, min(pa)
//pa + pb == pc
//pb + pc == pd    //pa + pb + pb == pd
*/
function problem44(input)
{
  function P(n) { return Math.floor( n*(3*n-1)/2 ); }

  var listP = [], mapP = {};
for ( var i = 1; i < 200000; i++ )
{
    var pi = P(i);
    mapP[pi] = i;
    listP[i] = pi;
}
  var len = listP.length;
  var maxP = listP[len-1];

  function isP( n )
  {
    /*if ( mapP[n] ) return true;
    while ( n >= maxP )
    {
      maxP = P(len);
      mapP[maxP] = len;
      listP[len] = maxP;
      len++;
    }*/

    return mapP[n];
  }


alert( maxP );
var res = 0;
var pa = 2000;

function iterate()
{
  if ( pa > len-2 )
    return res = 0;

  var pA = listP[pa];

  if ( pa % 100 == 0 )
    $("output").innerHTML += pa + ": " + pA + "<br />";
  if ( 3*pA >= maxP )
    return res = 0;

   for ( var pb = pa+1; pb < len-1; pb++ )
   {
    var pB = listP[pb];
    var pC = pA + pB;
    var pD = pB + pC;
    if ( isP(pC) )
    {

      if ( isP(pD) )
       {
         console.log( "found", pa, pb, mapP[pC], mapP[pD], ":", pA, pB, pC, pD );
         $("output").innerHTML += "found pa=" + pa + ", pb=" + pb + "<br />";
         return res = "found pa=" + pa + ", pb=" + pb;
       }
    }
    if ( pC < listP[pb+1]  || pD > maxP )
      break;
  }

  pa++;
  setTimeout( iterate, 10 );
}


iterate();
$("output").innerHTML += "done pa=" + pa + ", pb=" + pb;

  alert(res);

  return res; //"done pa=" + pa + ", pb=" + pb;
}

/*
A number chain is created by continuously adding the square of the digits in a number to form a new number until it has been seen before.
For example,
44 > 32 > 13 > 10 > 1 > 1
85 > 89 > 145 > 42 > 20 > 4 > 16 > 37 > 58 > 89
Therefore any chain that arrives at 1 or 89 will become stuck in an endless loop. What is most amazing is that EVERY starting number will eventually arrive at 1 or 89.
How many starting numbers below ten million will arrive at 89?
*/
function problem92()
{
var n = 44;

function next( n )
{
    if ( n == 1 || n == 89 )
        return n;

    var s = "" + n;
    var sum = 0;
    for ( var c = 0; c < s.length; c++ )
    {
        var ch = +s.charAt(c);
        sum += ch*ch;
    }
    return sum;
}

function chain( n )
{
    var res = [n];
    while ( n != 1 && n != 89 )
    {
        n = next( n );
        res.push(n);
    }
    return n;
}

var chains = { 1:1, 89:89 };

function arrive( n )
{
    if ( chains[n] )
        return chains[n];
    var n1 = next( n );

    return chains[n] = arrive(n1);
}

var count = 0;
for ( var i = 2; i < 10000000; i++ )
{
    var ar = arrive(i);
    if ( ar == 89 )
    {
        count++;
        if ( count % 1000 == 0 ) console.log( count );
    }
}

console.dir( "res:", count );

8581146
  return 0;
}

function problem82(input)
{
var data =
[[131,  673,  234,  103,  18],
[201,  96,  342,  965,  150],
[630,  803,  746,  422,  111],
[537,  699,  497,  121,  956],
[805,  732,  524,  37,  331]];  //994

var len = data.length, l1 = len-1;

for ( var c = len-2; c >= 0; c-- )
{
    console.log( c );

    var minU = [];
    minU[0] = data[0][c] + data[0][c+1];
    for ( var r = 1; r < len; r++ )
    {
        minU[r] = data[r][c] + Math.min( minU[r-1], data[r][c+1] );
    }

    var minD = [];
    minD[l1] = data[l1][c] + data[l1][c+1];
    for ( var r = l1-1; r >= 0; r-- )
    {
        minD[r] = data[r][c] + Math.min( minD[r+1], data[r][c+1] );
    }

    for ( var r = 0; r < len; r++ )
    {
        data[r][c] = Math.min( minU[r], minD[r] );
    }
}

  var min = Infinity;
    for ( var r = 0; r < len; r++ )
    {
        if ( data[r][0] < min )
            min = data[r][0];
    }

console.log( "min:", min )

  return min;  //260324
}


function problem38()
{
function isPandigital(n)
{
    var s = "" + n;
    var len = s.length;
    var count = 0;
    var digits = {};
    for ( var i = 0; i < len; i++ )
    {
        var c = s.charAt(i);
        if ( c == '0' ) return false;
        if ( digits[c] ) return false;
        digits[c] = true;
        count++;
    }
    return count == len;
}

for ( var i = 9476; i >= 9200; i-- )
{
    var d = i + "" + i*2;
    if ( isPandigital(d) )
        console.log( i, i*2 )
}

}

/*
If p is the perimeter of a right angle triangle with integral length sides, {a,b,c}, there are exactly three solutions for p = 120.
  {20,48,52}, {24,45,51}, {30,40,50}
For which value of p ? 1000, is the number of solutions maximised?
*/
function problem39(input)
{
  var s2 = [], o2 = {};
  for ( var i = 0; i < 500; i++ )
  {
     o2[i*i] = i;
     s2[i] = i*i;
  }

  var ps = {};
  for ( var a = 1; a < s2.length; a++ )
  {
     for ( var b = a; b < s2.length; b++ )
     {
        var c2 = s2[a] + s2[b];
        var c = o2[c2];
        if ( c )
        {
          console.log( a, b, c, ":", p );
          var p = a + b + c;
          if ( !ps[p] ) ps[p] = [];
          ps[p].push( [a,b,c] );
        }
     }
  }

  var maxL = 3, maxP = 120;  //
  for ( p in ps )
  {
     if ( ps[p].length > maxL )
     {
        console.log( ps[p].length, p, ps[p] );
        maxL = ps[p].length;
        maxP = p;
     }
  }
  console.log( maxP, maxL, ps[maxP] );

  return 0;
}

/*
By listing the set of reduced proper fractions for d ? 1,000,000 in ascending order of size, find the numerator of the fraction immediately to the left of 3/7.
*/
function problem71(input)
{
  var maxN = 2, maxD = 5, maxValue = 2/5, _37 = 3/7;
  for ( var d = 6; d <= 1000000; d++ )
  {
     var n = Math.floor( 3*d / 7 );
     var nd = n / d;
     if ( nd < _37 && nd > maxValue )
     {
        maxN = n;
        maxD = d;
        maxValue = nd;
        //console.log( n, d, nd );
     }
  }

  console.log( "max", maxN, maxD, maxValue );

  return maxN;  //428570
}


function problem72(input)
{
var uni = {}
var d = 2;
function collect()
{
  if ( d > 8000 )
  {
    setTimeout( calculate, 10 );
    console.log( "collected" );
    return;
  }

  for ( var n = 1; n < d; n++ )
  {
    uni["" + n/d] = true;
  }
  if ( d % 1000 == 0 )
    console.log( d );
  d++;
  setTimeout( collect, 10 );
}

function calculate()
{
  var count = 0;
  for ( var k in uni )
  {
    count++;
  }
  console.log( "count", count );
  return count;
}

}

/*
Problem 73
Consider the fraction, n/d, where n and d are positive integers. If n<d and HCF(n,d)=1, it is called a reduced proper fraction.
If we list the set of reduced proper fractions for d ? 8 in ascending order of size, we get:
1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8
It can be seen that there are 3 fractions between 1/3 and 1/2.
How many fractions lie between 1/3 and 1/2 in the sorted set of reduced proper fractions for d ? 12,000?
Note: The upper limit has been changed recently.
*/
function problem73()
{
var unique = {};
var i2 = 0.5, i3 = 1/3;
for ( var d = 5; d <= 120; d++ )
{
    var d2 = Math.floor( d / 2 );
    var d3 = Math.floor( d / 3 );
    console.log( d, d3, d2 );
    for ( var n = d3; n <= d2; n++ )
    {
        var nd = n / d;
        if ( nd < i2 && nd > i3 )
        {
            unique["" + n/d] = true;
        }
    }
}

var count = 0;
for ( var i in unique )
{
  console.log( i );
   count++;
}
count;

return 7295372;
}

/*
Problem 57
It is possible to show that the square root of two can be expressed as an infinite continued fraction.
v 2 = 1 + 1/(2 + 1/(2 + 1/(2 + ... ))) = 1.414213...
By expanding this for the first four iterations, we get:
1 + 1/2 = 3/2 = 1.5
1 + 1/(2 + 1/2) = 7/5 = 1.4
1 + 1/(2 + 1/(2 + 1/2)) = 17/12 = 1.41666...
1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29 = 1.41379...
The next three expansions are 99/70, 239/169, and 577/408, but the eighth expansion, 1393/985, is the first example where the number of digits in the numerator exceeds the number of digits in the denominator.
In the first one-thousand expansions, how many fractions contain a numerator with more digits than denominator?
*/
function problem57()
{
  var a = new BigInt(3), b = new BigInt(2), count = 0;
  for ( var ind = 2; ind < 1000; ind++ )
  {
    var ba = b.add( a );
    var bba = ba.add( b );
    var a = bba; // 2b + a
    var b = ba;  // b + a
    if ( a.len() > b.len() )
      count++;
  }
  return count;  // 153
}

/*
Find the minimal path sum, in matrix.txt, a 31K text file containing a 80 by 80 matrix, from the top left to the bottom right by only moving right and down.
*/
function problem81()
{
  var data =
  [[131,673,234,103,18],
  [201, 96, 342, 965, 150],
  [630, 803, 746, 422, 111],
  [537, 699, 497, 121, 956],
  [805, 732, 524, 37, 331]
  ];  // 2427

  var len = data.length;

  function getCandidates( r, c )
{
   var res = [];
   if ( r+1 < len && c < len )
      res.push( {r:r+1, c:c} );
   if ( r < len && c+1 < len )
      res.push( {r:r, c:c+1} );
   return res;
}
function getMinValue( candidates )
{
   if ( !candidates || candidates.length == 0 )
      return 0;
   if ( candidates.length == 1 )
      return data[candidates[0].r][candidates[0].c];

   var a = data[candidates[0].r][candidates[0].c];
   var b = data[candidates[1].r][candidates[1].c];
   return Math.min(a, b);
}

  for ( var startC = len-2; startC >= 0; startC-- )
  {
     for ( var r = len-1, c = startC; r >= 0 && c < len; r--, c++ )
        data[r][c] += getMinValue(getCandidates(r, c));
  }
  for ( var startR = len-2; startR >= 0; startR-- )
  {
     for ( var r = startR, c = 0; r >= 0 && c < len; r--, c++ )
        data[r][c] += getMinValue(getCandidates(r, c));
  }

  console.log( data[0][0] )

  return 427337;
}

function problem99()
{
  var data = [[519432,525806],
  [632382,518061],
  //...
  [172115,573985],
  [13846,725685]]

  var maxInd = -1, max = 0;
  for ( var i = 0; i < data.length; i++ )
  {
     var p = data[i][1] * Math.log(data[i][0]);
     if ( p > max )
        maxInd = i; max = p;
  }
  console.log( "final max:", maxInd+1, max );
}

/*
The 5-digit number, 16807=7^(5), is also a fifth power. Similarly, the 9-digit number, 134217728=8^(9), is a ninth power.
How many n-digit positive integers exist which are also an nth power?
*/
function problem63(input)
{

  var count = 0;
  for ( var p = 1; p < 23; p++ )
  {
    for ( var d = 1; d < 10; d++ )
    {
      var d_p = Math.pow( d, p );
      var len = ("" + d_p).length;
      if ( len == p )
      {
        console.log( d, "^", p, "=", d_p );
        count++;
      }
    }
  }
  console.log( count );
//~ 1 ^ 1 = 1
//~ 2 ^ 1 = 2
//~...
//~ 9 ^ 15 = 205891132094649
//~ 9 ^ 16 = 1853020188851841
//~ 9 ^ 17 = 16677181699666568
//~ 9 ^ 18 = 150094635296999140
//~ 9 ^ 19 = 1350851717672992000
//~ 9 ^ 20 = 12157665459056929000
//~ 9 ^ 21 = 109418989131512370000
// 9^22 has only 21 digits
//so the answer is  49
  return 49;
}


/*
The fraction ^(49)/_(98) is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that ^(49)/_(98) = ^(4)/_(8),
which is correct, is obtained by cancelling the 9s.
We shall consider fractions like, ^(30)/_(50) = ^(3)/_(5), to be trivial examples.
There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.
If the product of these four fractions is given in its lowest common terms, find the value of the denominator.
*/
function problem33(input)
{
//iterate: 10/11 .. 98/99
for ( var num = 10; num < 99; num++ )
{
  for ( var den = num+1; den < 100; den++ )
  {
    var num0 = Math.floor(num / 10), num1 = num % 10;
    var den0 = Math.floor(den / 10), den1 = den % 10;
    if ( num1 == 0 && den1 == 0 )
      continue;
    var frac = num / den;
    if ( num0 == den0 )
    {
      var canceled = num1 / den1;
      if ( frac == canceled )
        console.log( num, "/", den, "=", frac, "----",  "num1 / den1", canceled );
    }
    else if ( num0 == den1 )
    {
      var canceled = num1 / den0;
      if ( frac == canceled )
        console.log( num, "/", den, "=", frac, "----",  num1, "/", den0, canceled );
    }
    else if ( num1 == den0 )
    {
      var canceled = num0 / den1;
      if ( frac == canceled )
        console.log( num, "/", den, "=", frac, "----",  "num0 / den1", canceled );
    }
    else if ( num1 == den1 )
    {
      var canceled = num0 / den0;
      if ( frac == canceled )
        console.log( num, "/", den, "=", frac, "----",  "num0 / den0", canceled );
    }
    else
      continue;
    //~ 16 / 64 = 0.25 = 1 / 4
    //~ 19 / 95 = 0.2 = 1 / 5
    //~ 26 / 65 = 0.4 = 2 / 5
    //~ 49 / 98 = 0.5 = 1 / 2
    //~ --> 100
  }
}

  return count;
}


/*
Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).
If d(a) = b and d(b) = a, where a ? b, then a and b are an amicable pair and each of a and b are called amicable numbers.
For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.
Evaluate the sum of all the amicable numbers under 10000.
*/
function problem21(input)
{

  function findFactorsSum( n, primes, log )
  {
    var res = {1:true};
    var sum = 1;

    function add( p )
    {
      if ( !res[p] )
      {
        res[p] = true;
        sum+=p;
      }
    }

    var lim = Math.sqrt(n);

    for ( var key in primes )
    {
      var p = +key;
      if ( p > lim )
        break;
      if ( n % p === 0 )
      {
        add( p );
       var p1 = Math.floor(n / p);
       add( p1 );

        for ( var i = 2*p; i < p1; i+=p )
        {
          if ( n % i === 0 )
          {
            add(i);
            add( Math.floor(n / i) );
          }
        }
      }
    }
    //add( n );
    if ( log )
    {
      var f = [];
      for ( var k in res )
      {
        f.push( +k );
      }
      //console.log( res );
      return f.join( ',' );
    }

    return sum;
  }

var hash = {};
var amicable = [];
for ( var i = 2; i < 10000; i++ )
{
    var fc = findFactorsSum( i, primes, false );
    hash[i] = fc;
    if ( fc != i && hash[fc] == i )
    {
        amicable.push( [i, fc] );
        console.log( i, fc );
    }
}
console.log( amicable );

//~ 284 + 220 +
//~ 1210 + 1184 +
//~ 2924 + 2620 +
//~ 5564 + 5020 +
//~ 6368 + 6232
//~ ==
//~ 31626

  return 0;
}


function problem79()
{
  // find a digit, which have no precedent  - it's first.
  return 73162890;
}

function problem53()
{

function f( n )
{
    if ( f[n] )
        return f[n];

    if ( n == 0 )
        return 1;

    return f[n] = n * f(n-1);
}

function C(r, n)
{
    var res = 1;

    for ( var num = r+1; num <= n; num++ )
    {
        res *= num;
    }

    for ( var den = 1; den <= n-r; den++ )
    {
        res /= den;
    }
    return res;
}


var count = 0;

for ( var n = 21; n <= 100; n++ )
{
    //var r = 4;
    for ( var r = 4; r < n; r++ )
    {
        var c = C(r, n);
        console.log( "r:", r, "n:", n, "c(r,n):", c );
        if ( c > 1000000 )
        {
            console.log( " FOUND! r:", r, "n:", n, "c(r,n):", c );
            count++;
        }
    }
}
console.log( "answer", count );

}

/*
coins:    1p, 2p, 5p, 10p, 20p, 50p, ?1 (100p) and ?2 (200p).
It is possible to make ?2 in the following way:
    1??1 + 1?50p + 2?20p + 1?5p + 1?2p + 3?1p
How many different ways can ?2 be made using any number of coins?
*/
function problem31(input)
{

  var coinsValues = { p1: 1, p2:2, p5:5, p10:10, p20:20, p50:50, l1:100, l2:200 };

  function emptyVariant() { return { p1:0, p2:0, p5:0, p10:0, p20:0, p50:0, l1:0, l2:0 } };
  var coinsNames = [ 'p1', 'p2', 'p5', 'p10', 'p20', 'p50', 'l1', 'l2' ];

  function makeO( n, ind )
  {
    if ( n < 0 )
      return null;
    if ( n == 0 )
      return [ {} ];
    var currCoin = coinsNames[ind];
    var last = coinsValues[currCoin];
    if ( ind == 0 )
    {
      if ( n % last === 0 )
      {
        var count = n / last;
        var res = {};
        res[ currCoin ] = count;
        return [ res ];
      }
      return null;
    }
    else
    {
      var count = 0;
      var res = [];
      do
      {
        var sum = last*count;
        var rest = n - sum;
        var tempRes = makeO( rest, ind-1 );
        if ( tempRes )
        {
          if ( count != 0 )
            tempRes.forEach( function( tr ) { tr[ currCoin ] = count; } );
          res = res.concat( tempRes );
        }
        count++;
      }
      while ( sum < n )

      return res;
    }
  }

  var ret = makeO( +input || 200, coinsNames.length-1 );

  return ret.length;    // 73682
}



/*
Triangle       T_(n)=n(n+1)/2       1, 3, 6, 10, 15, ...
Pentagonal       P_(n)=n(3n?1)/2       1, 5, 12, 22, 35, ...
Hexagonal       H_(n)=n(2n?1)       1, 6, 15, 28, 45, ...
It can be verified that T_(285) = P_(165) = H_(143) = 40755.
Find the next triangle number that is also pentagonal and hexagonal.
*/
function problem45(input)
{

function tria(n)   { return Math.floor( n * (n+1) / 2 ); }
function penta(n)   { return Math.floor( n * (3*n-1) / 2 ); }
function hexa(n)   { return n * (2*n-1); }

function isTria(t)
{
    var t2 = t*2;
    var sqr = Math.floor(Math.sqrt( t2 ));
    if ( t2 == sqr*(sqr+1))
    return sqr;
  else if  ( t2 == sqr*(sqr-1) )
    return sqrt-1;
  else
    return 0;
}

var curr = 40755,
   t = 285+1,
   p = 165+1,
   h = 143+1;

var candT = tria( t );
var candP = penta( p );
var candH = hexa( h );

var lim = 1000;
while ( lim > 0 )
{
  lim--;
  while ( candP < candH )
  {
    p++;
    candP = penta( p );
  }

  if ( candP == candH )
  {
    console.log( "p=h", p, h, candP );
    var isT = isTria( candP );
    if ( isT != 0 )
    {
      t = isT;
      console.log( "found: t=p=h", isT, p, h, candP );
      break;
    }
  }
  else
  {
    h++;
    candH = hexa(h);
    if ( h % 100 == 0 )
      console.log( "hex", h, candH );
  }
}

console.log( "res: ", t, p, h, tria( t ), penta( p ), hexa( h ) );

  //t=p=h 55385 31977 27693 1533776805
}

function problem12(input)
{
  var primes = Sieve_of_Eratosthenes(1000000);

  function findFactorsCount( n, primes, log )
  {
    var res = {1:true};
    var count = 1;

    function add( p )
    {
      if ( !res[p] )
      {
        res[p] = true;
        count++;
      }
    }

    var lim = Math.sqrt(n);

    for ( var key in primes )
    {
      var p = +key;
      if ( p > lim )
        break;
      if ( n % p === 0 )
      {
        add( p );
       var p1 = Math.floor(n / p);
       add( p1 );

        for ( var i = 2*p; i < p1; i+=p )
        {
          if ( n % i === 0 )
          {
            add(i);
            add( Math.floor(n / i) );
          }
        }
      }
    }
    add( n );
    if ( log )
    {
      var f =[];
      for ( var k in res )
      {
        f.push( +k );
      }
      //console.log( res );
      return f.join( ',' );
    }

    return count;
  }

  //var curr = 0, ind = 0, currMaxFactors = 0, currMax = 0, lim = 500;
  var curr = 75651150, ind = 12300, currMaxFactors = 480, currMax = 2162160, lim = 500;
  //curr: ind=12300 val=75651150 max=480

  function iterate()
  {
    while ( currMaxFactors < lim )
    {
      ind++;
      curr += ind;
      //curr   ===   var nth = Math.floor( ind * (ind + 1 ) / 2 );
      var factorsCount = findFactorsCount( curr, primes );
      if ( factorsCount > currMaxFactors )
      {
        currMaxFactors = factorsCount;
        currMax = curr;
        console.log( "max:", ind, curr, currMaxFactors);
        $("output").innerHTML += "<br/>  MAX: ind=" + ind + " val=" + curr +
          " max=" + currMaxFactors + " in=" + currMax;
        if ( currMaxFactors >= 500 )
           break;
      }

      if ( ind % 100 === 0 )
      {
        $("output").innerHTML += "<br/>curr: ind=" + ind + " val=" + curr +
          " max=" + currMaxFactors + " in=" + currMax;
        console.log( "curr:", ind, curr, currMaxFactors);
        setTimeout( iterate, 10 );
        return;
      }
    }

    console.log( "final:", ind, currMax, currMaxFactors );

    return ;
  }

  iterate();
  //~ $("output").innerHTML  += "76576500 = " +
    //~ findFactorsCount( 76576500, primes, true );

  return currMax;
}



/*
Find the value of d < 1000 for which ^(1)/_(d) contains the longest recurring cycle in its decimal fraction part.
*/
function problem26(input)
{
  function div( numerator, denominator, fraction )
  {
    var remainders = {};
    while ( fraction.length < 1000 )
    {
      numerator *= 10;
      while ( numerator < denominator )
      {
        numerator *= 10;
        fraction.push( 0 );
      }
      var quotient = Math.floor( numerator / denominator );
      var remainder = Math.floor( numerator % denominator );
      fraction.push( quotient );
      numerator = remainder;
      if ( remainders[remainder] )
      {
        var prevLen = remainders[remainder];
        var currLen = fraction.length;

        return { fraction: '0,' + fraction.join(''), n: denominator, len: currLen-prevLen };
      }
      remainders[remainder] = fraction.length;
    }

    //nothing return // return '0,' + fraction.join('');
  }

  var max = 0;
  var ind = 0;
  for( var n = 999; n > 6; n-- )
  {
    var fr  = div( 1, n, [] );
    if ( fr && fr.len > max )
    {
      max = fr.len;
      ind = n;
      console.log( fr );
    }
  }

  console.log( ind, max );  // 983, 982
  return ind;
}

/*
The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.
Find the sum of the only eleven primes that are both truncatable from left to right and right to left.
NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.
*/
function problem37(input)
{
  var primes = Sieve_of_Eratosthenes(1000000);
  var trunc = [];
  for ( p in primes )
  {
     if ( p < 10 ) continue;
     if ( isTruncatable(p) )
     {
        trunc.push( p );
        if ( trunc.length == 18 ) break;
     }
  }

  var s = 0;
  for ( var n = 0; n < trunc.length; n++ )
     s += trunc[n];
  return s; //748317;
}


/* What is the greatest product of four adjacent numbers in any direction (up, down, left, right, or diagonally) in the 20?20 grid? */
function problem11(input)
{
  function maxH()
  {
    var max = 0;
    square.forEach( function(row, ind)
    {
      for ( var i = 0; i < row.length-3; i++ )
      {
        var prod = row[i] * row[i+1] * row[i+2] * row[i+3];
        if ( prod > max )
        {
          max = prod;
        }
      }
    } );
    return max;
  }

  function maxV()
  {
    var max = 0;
    for ( var c = 0; c < square[0].length; c++ )
    {
      for ( var r = 0; r < square.length-3; r++ )
      {
        var prod = square[r][c] * square[r+1][c] * square[r+2][c] * square[r+3][c];
        if ( prod > max )
        {
          max = prod;
        }
      }
    };
    return max;
  }

  function maxDL()
  {
    var max = 0;
    for ( var c = 0; c < square[0].length-3; c++ )
    {
      for ( var r = 0; r < square.length-3; r++ )
      {
        var prod = square[r][c] * square[r+1][c+1] * square[r+2][c+2] * square[r+3][c+3];
        if ( prod > max )
        {
          max = prod;
        }
      }
    };
    return max;
  }

  function maxDR()
  {
    var max = 0;
    for ( var c = square[0].length-1; c >= 3; c-- )
    {
      for ( var r = 0; r < square.length-3; r++ )
      {
        var prod = square[r][c] * square[r+1][c-1] * square[r+2][c-2] * square[r+3][c-3];
        if ( prod > max )
        {
          max = prod;
        }
      }
    };
    return max;
  }

  var square =
  [    [08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08],
    //....
    [01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48]  ];

  var v = maxV();
  var h = maxH();
  var dl = maxDL();
  var dr = maxDR();

  // 51267216 48477312 40304286 70600674
  // total max 70600674
  var max = Math.max( v, h, dl, dr );

  return max;
}

/* How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)? */
function problem19()
{
  var count = 0;
  for ( var y = 1901; y < 2001; y++ )
  {
     for ( var m = 0; m < 12; m++ )
     {
        var d = new Date( y, m, 1 )
        if ( d.getDay() == 0 )
        {
          console.log( d );
          count++;
        }
     }
  }
  return count;
}

function problem35()
{
  function getRotations( n )
  {
     var s = "" + n;
     var len = s.length;
     var res = [];
     for ( var i = 0; i < len; i++ )
     {
        res.push( s );
        var c = s.charAt(0);
        s = s.substring(1) + c;
     }

     return res;
  }

  var primes = Sieve_of_Eratosthenes(1000000);

  var answer = {}
  for ( p in primes )
  {
    var rot = getRotations( p );
    if ( rot.every( function(r) { return primes[r]; } ) )
    {
      rot.forEach( function(r) { delete primes[r]; answer[r] = true; } );
    }
  }

  var aa = [];
  for ( var a in answer )
  {
    aa.push( a );
  }
  return aa.length;  // 55
}

/*
The n^(th) term of the sequence of triangle numbers is given by,
t_(n) = ?n(n+1); so the first ten triangle numbers are:
  1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
By converting each letter in a word to a number corresponding to its alphabetical position
and adding these values we form a word value. For example,
the word value for SKY is 19 + 11 + 25 = 55 = t_(10).
If the word value is a triangle number then we shall call the word a triangle word.
Using words.txt (right click and 'Save Link/Target As...'),
a 16K text file containing nearly two-thousand common English words, how many are triangle words?
*/
function problem42(input)
{
  function nextTriangle( n )
  {
      return n * (n+1) / 2;
  }

  var curr = 3;
  for ( var i = 1; i <= 10; i++ )
  {
      curr = nextTriangle(i);
      console.log( i, curr );
  }

  var letters = {};
  var a = "A".charCodeAt(0);
  for ( var i = 0; i < 26; i++ )
  {
      letters[String.fromCharCode( i+a )] = i+1;
  }
  // {A=1 B=2 C=3 D=4 E=5 F=6 G=7 H=8 I=9 J=10 K=11 L=12 M=13 N=14}
  console.log( letters );

  var words = ["A","ABILITY","ABLE",        "YOURSELF","YOUTH"];
  var maxCode = 0;
  words.forEach( function(w)
  {
      var code = wordCode(w);
      if ( code > maxCode )
      {
          maxCode = code;
          console.log( w, w.length, code );
      }
  } );
  //max code: RESPONSIBILITY 14 192

  var triangles = {};
  for ( var i = 1; i <= 20; i++ )
  {
      triangles[nextTriangle(i)] = i;
  }
  // { 1=1 3=2 6=3 10=4 15=5 21=6 28=7 36=8 45=9 55=10 66=11 78=12 ... 210=20}

  var howMany = 0;
  words.forEach( function(w)
  {
      var code = wordCode(w);
      if ( triangles[code] )
      {
          console.log( w, code, triangles[code] );
          howMany++;
      }
  } );

  return howMany;
}


function problem24()
{
  function permutation(list)
  {
    if (list.length < 1)
      return [];
    if (list.length < 2)
      return [ list.charAt(0) ];
    if (list.length < 3)
      return [ list, list.charAt(1) + list.charAt(0) ];

    var res = [];
    for ( var i = 0; i < list.length; i++)
    {
      var curr = list.charAt(i);
      var cutted = cut(list, i);
      var perm1 = permutation(cutted);
      var perm = perm1.map(function(tr) { return curr + tr; } );
      res = res.concat(perm);

      var len = res.length;
      if (len > 1000000)
      {
        console.log("res[1000000]=", res[1000000]);
        console.log("res[1000000-1]=", res[1000000 - 1]);
        return;
      }
      if (len % 1000 == 0)
      {
        console.log("res[" + i + "]=", res[i]);
      }
    }
    return res;
  }

  cut = function(s, n)
  {
    return s.substring(0, n) + s.substring(n + 1);
  };

  permutation("0123456789");
//  res[1000000-1]= 2783915460
}

function problem40(input)
{
  var BigString =
  {
    buffer: "",
    currStart: 0,

    add: function( s )
    {
      this.buffer += curr;
    },

    len: function()
    {
      return this.currStart + this.buffer.length;
    },

    flush: function()
    {
      var len = this.buffer.length;
      if ( len <= 1000 )
        return;
      var rem = len % 1000;
      this.currStart = len-rem;
      this.buffer = this.buffer.substring(this.currStart);
    },

    nth: function(n)
    {
      n = n-1;
      if ( n < this.currStart )
        throw Error( "too late" );
      if ( n > this.currStart + this.buffer.length )
        throw Error( "too early" );

      return this.buffer.charAt(n - this.currStart );
    }
  };


  var check = 1, res = [];

  for ( var i = 1; i <= 223456; i++ )
  {
      var curr = "" + i;
      BigString.add(curr);
      if ( BigString.len() > check )
      {
          var checked = BigString.nth( check );
          res.push([i, check + "th: ", checked]);

          console.log( "------", i, check + "th: ", checked );
          console.log( "len=", BigString.buffer.length, "start=", BigString.currStart );
          BigString.flush();
          console.log( "len=", BigString.buffer.length, "start=", BigString.currStart );

          check *= 10;
          if ( check > 1000000 )
            return res;
      }
  }

  return 0;
}

function problem48( input )
{

  //8739992577

  function d1(n)
  {
    return ["", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine",
            "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen",
            "Seventeen", "Eighteen", "Nineteen"][n];
  }

  function d2(n)
  {
    var b = Math.floor(n / 10);
    var a = n % 10;
    return ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"][b] + d1(a);
  }

  function toWord( n )
  {
    if ( n < 20 )
      return d1(n);

    if ( n < 100 )
      return d2(n)

    var c = Math.floor(n / 100);
    var ba = n % 100;
    return d1(c) + "hundred" + toWord(ba);
  }

  var output = $("output");
  var sum = 0;
  for ( var i = 1; i < 1000; i++ )
  {
     var word = toWord(i);
     sum += word;
     //console.log( i, word );
     //output.innerHTML += "<br>" + i + " " + word;
  }

  return sum;
}



/*
The decimal number, 585 = 1001001001_(2) (binary), is palindromic in both bases.
Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.
(Please note that the palindromic number, in either base, may not include leading zeros.)
*/
function problem36( input )
{
  function isPalindrom( string )
  {
      var len = string.length;
      if ( len <= 0 )
          return false;
      if ( len == 1 )
          return true;

      for ( var l = 0, r = len-1; l<r; l++, r-- )
      {
          if ( string.charAt(l) != string.charAt(r) )
              return false;
      }

      return true;
  }

  var limit = 1000000;
  var res = [];

  function check( binString )
  {
      var dec = parseInt( curr, 2 );
      var decString = "" + dec;
      if ( dec < limit && isPalindrom( decString ) )
      {
          res.push( [binString, dec] );
          console.log( binString, dec );
      }

      return dec >= limit;
  }

  var candidate = ["11"];
  var curr = 3;
  while (candidate.length > 0)
  {
      curr = candidate.shift();
      if ( check(curr) )
          break;

      var middle = curr.length / 2;
      var left = curr.substring( 0, middle );
      var right = curr.substring( middle );

      curr = left + "0" + right;
      if ( check(curr) )
        break;
      curr = left + "1" + right;
      if ( check(curr) )
        break;

      candidate.push( left + "00" + right );
      candidate.push( left + "11" + right );
  }

  var currDec = parseInt( curr, 2 );
  console.log( "---------", currDec );

  for (var i = 0; i < candidate.length > 0; i++ )
  {
      var curr = candidate[i];
      check( curr );
  }


  return res;
}


function problem14( input )
{

  function next( n )
  {
    if ( n == 1 )
      return 0;
    if ( n % 2 == 0 )
      return n / 2;
    else
      return 3 * n + 1;
  }

  function chain( n )
  {
    var pr = [];
    while ( n > 1 )
    {
      pr.push(n)
      n = next( n );
    }

    return pr;
  }

  var lens = [];
  lens[1] = 1;
  function chainLen( n )
  {
    if ( lens[n] )
      return lens[n];

    var n1 = next(n);
    var l1 = chainLen( n1 );
    return lens[n] = l1+1;
  }

  for ( var i = 2; i < input; i++ )
  {
    var len = chainLen(i);
    if ( i % 500 == 0)
      console.log( i, len );
  }

  var max = 0, maxInd = -1;
  for ( var key in lens )
  {
    var len = lens[key];
    if ( len > max )
    {
      maxInd = key;
      max = len;
    }
  }
  console.log( "maxInd: ", maxInd, "max: ", max );

  return maxInd;
}

function problem10( input )
{
  var lim = input || 2000000;
  var sqrtLim = Math.sqrt(lim);

  var era = [];
  for ( var i = 0; i < lim; i++ )
    era[i] = true;

  era[0] = false;
  era[1] = false;

  var primes = [], curr = 2;

  function onePrime()
  {
    primes.push(curr);
    for ( var i = curr*curr; i < lim; i+=curr )
    {
      era[i] = false;
    }

    do
    {
      curr++;
    }
    while ( !era[curr] && curr < sqrtLim);
  }

  function it(  )
  {
    for( var i = 0; i < 100 && curr < sqrtLim; i++ )
      onePrime();

    if ( curr < sqrtLim )
    {
      console.log( curr );
      setTimeout( function()
      {
         it();
      }, 10 );
    }
    else
      return calcsum( primes );
  }

  function calcsum( primes )
  {
    var sum = 0;
    for ( var i = 0; i < primes.length; i++ )
      sum += primes[i];

    console.log( "sum = ", sum );
    $("output").innerHTML += "sum = " + sum;

    return sum;
  }


  it( );
}


function runWorker()
{
  var input = $("input").value;

  var worker = new Worker("my_worker.js");

  //receive message from the worker
  worker.onmessage = function(event){
      alert(event.data);
  };

  //send message to the worker
  worker.postMessage("Nicholas");

  worker.onerror = errorReceiver;

  var res = problem( +input );

  $("output").innerHTML += res;
}
/*
//in worker.js
//receive message from the page
self.onmessage = function(event){

  //send message back to the page
  this.postMessage("Hello, " + event.data);
};
*/


//problem 9
//Find the only Pythagorean triplet, {a, b, c}, for which a + b + c = 1000.
//a=200 b=375 c=425,
//It can easily be seen that for every Pythagorean triplet a > 3 and a + b + c is
//even, you might want to prove that yourself.


function problem3(input)
{
//  var target = 600851475143;

  function divide(n, divs, pm)
  {
    var maxPr = pm.maxPrime;
    if ( n > maxPr*2 || pm.isComposite(n)  )
    {
      if (n % maxPr == 0)
      {
        divs.push( maxPr );
        return divide(n / maxPr, divs, pm);
      }
      else
      {
        pm.findNextPrime();
      }

      return divide(n, divs, pm)
    }
    else
    {
      divs.push(n);
      return divs;
    }
  }

  var pm = new PM();
  var ret = divide(input, [], pm);

  var product = 1;
  for ( var p = 0; p < ret.length; p++ )
    product *= ret[p];
  console.log( "product = ", product );

  return ret;
}

function problem7( lim )
{
  var pm = new PM(), pr;
  var limit = lim || 10001;
  for ( var i = 1; i < limit; i++ )
  {
    pr = pm.findNextPrime();
    if ( i % 200 == 0 )
    {
      console.log( i, pr );
    }
  }

  return pr;
}


// primes manager
function PM()
{
  this.primes = { 2:true, 3:true };
  this.maxPrime =  2;
}
PM.prototype =
{
  isKnownPrime: function(n) { return this.primes[n]; },

  hasKnownDivisors: function( n )
  {
    var lim = Math.sqrt(n);
    for ( var key in this.primes )
    {
      var p = +key;
      if ( p > lim )
        return false;
      if (n % p == 0)
        return true;
    }
    return false;
  },

  isComposite: function( n )
  {
    return !this.isKnownPrime(n) && this.hasKnownDivisors(n);
  },

  findNextPrime: function()
  {
    if ( this.maxPrime == 2 )
      return this.maxPrime = 3;

    var nextPrime = this.maxPrime + 2
    while (this.hasKnownDivisors(nextPrime))
    {
      nextPrime += 2
    }
    this.primes[nextPrime] = true

    return this.maxPrime = nextPrime;
  }
};

